분할정복 알고리즘 (Divide and Conquer Algorithm)
 - 주어진 문제의 크기가 감당하기 어려운 경우 보다 작은 문제로 나누어 해결하는 알고리즘
 - 이진검색, 퀵 정렬, 합병정렬 등이 예

이진 검색 (Binary Search)
 - 정렬된 데이터 리스트에서 목표값 또는 목표값이 있는 위치를 빠른 시간에 찾는 분할 정복 알고리즘의 하나
 - 정렬된 데이터라는 조건이 있다
 - 시간 복잡도 : O(log(n))
 - 이 검색 알고리즘 프로세스 :
 - - 1) 현재 탐색 구간의 가운데 배열번호(index) mid를 구한다 {mid = (low + high) / 2}
 - - 2) A[mid]값과 target값을 비교한다
 - - - 2.1) A[mid] == target // 목표값 또는 목표값의 위치 찾음
 - - - 2.1) A[mid] < target // low = mid + 1로 하여 검색 범위 조정
 - - - 2.1) A[mid] > target // high = mid - 1로 하여 검색 범위 조정
 - - 3) 탐색 구간이 남아있고 값을 찾지 못한경우는 위의 1), 2)번 과정 반복
 - - 4) low > high (탐색구간이 없는 경우)는 목표값이 존재 하지 않음을 나타낸다

퀵정렬 (Quick Sort)
 - 원소들간의 비교와 교환을 통하여 정렬하는 비고기반정렬 알고리즘
 - 원소들 중에 같은 값이 있는 경우 정렬후에 이들의 순서가 바뀔수 있는 불안정 정렬이다
 - 시간복잡도 : 평균 O(N * logN), 최악 O(N^2)
 - 합병정렬과 다르게 비대칭 분할이 이루어지며 분할과 정복 과정은 있으나 합병과정이 없다
 - 오름차순 알고리즘
 - - 배열 arr[], 구간 시작 인덱스 low, 끝 인덱스 high
 - - 1) low >= high 라면 현재 구간은 정렬된 것으로 본다.
 - - 2) 분할(Divide) 과정 :
 - - - 구간내의 임의의 원소를 pivot값으로 정한다. 여기서는 pivot = arr[high]로 정한다
 - - - 2.1) pivot 이하의 값들은 배열의 왼쪽에 이상의 값은 오른쪽에 배치한다.
 - - - 2.2) pivot의 자리를 찾아준다.
 - - - - pivot을 제외한 부분을 3구간으로 나누어 처리한다.
 - - - - 2.2.1) arr[low] ~ arr[i] : pivot보다 작거나 같은 값들로 이루어진 구간
 - - - - 2.2.2) arr[i + 1] ~ arr[j] : pivot보다 크거나 같은 값들로 이루어진 구간
 - - - - 2.2.3) arr[j + 1] ~ arr[high - 1] : 아직 처리되지 않은 구간
 - - - - 이 과정을 의사코드로 표현
 - - - - - i = low -1;
 - - - - - for (j = low; j<high; j=j+1){
 - - - - -  if(arr[j] < pivot) swap(arr[++i], arr[j]);
 - - - - - }
 - - - - - swap(arr[++i], arr[high]);
 - - 3) 정복(Conquer) 과정 :
 - - - pivot을 기준으로 왼쪽과 오른쪽을 재귀호출하여 정렬 시킨다.
 - - - quickSort(arr, low, i-1)
 - - - quickSort(arr, i+1, high)
